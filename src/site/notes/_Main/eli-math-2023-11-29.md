---
{"dg-publish":true,"permalink":"/main/eli-math-2023-11-29/","noteIcon":""}
---

- has a thing with fancy proofs that are rust objects
	- something formulizes them into a raw formula
	- arguments could appear in different orders
		- all of these are valid
		- stuck on: premises
			- proofs rely on premises
			- premesies need an order when they get internalized
			- order doesn't matter
				- any order is provably equal to another order
				- need to pick an order to prove the function
				- order isn't the problem right now
			- problem is the other thing, the weakness level.
				- all true statements are of the form a=b
				- hierarchy of weaker versions, true equals a+b is stronger than equals a+b
					- weaker but easier to prove every time
					- if you can prove one, weaker can prove a stronger
					- if you haven't proved it, it's not a clue
				- weakness levels 
					- fancy proofs to prove any number of levels
						- you can:
							- use a rule, that rule has several premises
							- minimum weakness level that the proof is useful at
							- relies on other things that are a certain weakness level
							- but it will also prove the same thing at a higher weakness level
								- if you prove at a higher level, you can just weaken it using the direct proof that something implies it's weaker version
					- when you have the rule case that may use more than one sub-proof, the subproofs may have a different minimum weakness level
					- to combine them you probably want to adjust to be the same weakness level
						- multiple choices:
							- give me the internal version of the fancy proof -- what premise, what argument order, what weakness level you want.
								- internalization function includes the weakening stack
								- part of eli says this is inelegant; provide strongest version and weaken it yourself
								- function recursive, in the rule case it calls the internalization function of it's sub-proofs
									- two branches:
									- tell subproof "I want this at this weakness level" and they manually weaken if they need to
									- or "give me your minimum weakness level and I will weaken it"
								- "why can't I design it either of the ways and just write out the cases"
									- the actual thing is the parts of this eli doesn't know how to impliment yet
										- haven't yet put the details together
										- one is active weakening itself
											- easy enough, haven't done transfinite things yet, just adding true equals a bunch of times
												- to do this you must know how many levels of true equals you have to add
												- wants to think forward to trans-finite levels.
												- ordinal crash course
													- some finite levels of true equals under which foo is true
													- if you have foo, you can move up to finite levels of true implies foo
													- if you have true equals foo, we probably want to strip off that true equals, which you can do because one plus omega equals omega.
													- weaken from a particular ordinal to another
														- those are equal, presumably they will be internally equal to each other, able to convert between
														- wants to have omega be the canonical omega, instead of written as 1+omega
											- in his rust code, often some form of true equals followed by preposition
												- could store as a formula, match on formula under trues, get number of level of true
													- if wasn't in that form, would get an error. 
													- but thats weird
													- \<missed it> know something about the form of that formula
													- no good approach to wrappers
													- formula has no knowledge of what it is
													- had an epiphany to use types but i forget the context
													- bad and messy code potential
													- forgot what they were saying
													- nested generic types that all have a formula trait
													- has a type formula, metatypes.  \<missed the first> Formula that is raw, formula that  is an equality statement
													- almost form a class inheritance diagram, but fully diamond problem'd
														- if it's a lattice, then... huh
														- what's the best way to-- 
															- formula that's an equality statement, \<missed it>, raw equality statement
															- raw: function to get two sides of it would be able to return raw formula
															- an option is to manually impliment every case that you happen to have.
															- primary hesitation: would like to get the framework correct the first time
														- generic type where you say what formula, others where different levels of what is known is hardcoded
														- sometimes has a type that generates a formula
															- the type has several fields, like a struct.
															- fields induce a formula
															- methods you call that generates the formula
														- other times, wrapper types wrap formula, knows about formula, and uses projection functions
														- two ways of doing the same thing
															- substantive meaning is exactly the same
															- implimented in diffrent ways
														- wants to clean up code to standardize
														- formula should already be computed so you don't have to re-create it next time
															- caching and redundancy
															- ok because these objects will be immutable.
														- some things wrapping formulas aren't formulas
															- inferences aren't formulas
																- premises and conclusions have to be equality statements
																- equality statements that are in inferences, whether they are formulas or not, is kind of ambiguous
																- maybe equality is an intrinsic that is separate from the fact that there are formulas written with the equals atom
																- maybe an equality is not a formula, but it just has an internalization that is a formula
																- unclear if most convenient way to write the  code
														- writing out math stuff as programming forces rigorousness
														- a type of equality statement that happens to have \<fell behind>
															- sometihng about method calls
															- something about automatic dereferencing calls, unless you generate it on the fly
															- could manually forward the methods
															- certainly easy enough to have 'equality statement' be a type that is a wrapper type around Formula
															- would be nice to figure out a solution for the diamond problem for figuring out whether formulas are pretty or raw
																- in all of the proof code, whether correct or not depends only on the raw form
																- may want to keep the pretty form so you can look at them and not have them be turned into giant messes of combinators
																- biggest pitfall is that later, if you accidentally write a=b and they're different pretty forms, but you want to check if they're the same in their raw form, now you have a bug
																- you can't just have these be properties or whatever, because you might want to compare notation instead of raw form.
																- function type that is a body plus list of arguments that is an order
																	- carries things that aren't part of the formula itself
																	- has multiple ways it can be interpreted, more like inferences, object with multiple possible internalizations
																- want to make them generic types so that you can have the formula that's inside be a pretty formula or not
																	- might accidentally do a pretty formula comparison when you want to do a raw comparison
																	- maybe that could be part of the type, compare as raw / compare as pretty etc
																	- can you write a macro for this?
																		- by using macros you could do this instead of repeating code
																		- particular thing you're thinking of is need wrapper types like compare_as_raw and compare_as_pretty for the um--
																			- that means your inference type would take a generic parameter that impliments the trait formula
																			- the actual object it stored would be wrappers
																				- they would be:
																				- compare as raw equality of that formula type
																				- or maybe equality of compare as raw of that formula type
																				- compare as raw should go on the outside, you guess
																				- doesn't know if you want to do all of this, might make some annoying boilerplate just to get rust to make it as convenient to use as you want
																					- shouldnt' be any annoying boilerplate because once you ultimately--
																					- should be able to get it into type definitions instead of useage sites
																					- one of the principles you consider is "make the useage site clean, and then don't worry about how much annoying stuff is in the definition"
																					- worried if you don't figure out this, when you go and do the annoying code and do the definitions to make it convenient at the useage site, it'll be too annoying and you'll spend too much time on that.
									- weakness levels again
										- wanted to make a type that was -- formula that is \<fell behind>
											- missed a few things
											- known to be an equality state
												- already know how to unwrap
												- can just write the weak statement type using the current ad-hocness approach instead of doing type hierarchy
												- don't know that you'll ever actually have a case where you will need to know more stuff about the formula inside the weakness thing
												- if you do, you think you can just do another hacky thing instead of--
- now talking about foams, open cell foam, etc
	- gamma knife
	- 